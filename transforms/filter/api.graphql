# The `ecmascript` argument is great for writing filters.
# See https://stepzen.com/docs/custom-graphql-directives/directives#ecmascript for more information on `ecmascript`.
# We are picturing a real-life scenario in which you call a backend using the `endpoint` argument.
# See https://stepzen.com/docs/connecting-backends/how-to-connect-a-rest-service for more information on `@rest`.

type Customer {
  id: ID
  name: String
}

type Query {
  customer(name: String!): [Customer]
    @rest(
      endpoint: "https://sample-api.us-east-a.apiconnect.automation.ibm.com/api/customers"
      ecmascript: """
      function transformREST(s) {
          var name = get('name')
          var data = JSON.parse(s)
          var output = []
          for (var i=0; i < data.length; i++) {
              if (data[i]['name']==name)
                  output.push(data[i])
          }
          return JSON.stringify(output)
      }
      """
    )
}

# jsonata transforms provdes an alternate method for filtering
# customer_1 uses the [ ... ] filter to return all "customers" ($) that
# contain name = the argument name
# jsonata has quirks: if you leave out the outer []

extend type Query {
  customer_1(name: String!): [Customer]
    @rest(
      endpoint: "https://sample-api.us-east-a.apiconnect.automation.ibm.com/api/customers"
      transforms: [ { editor:"""jsonata:$[name = $get("name") ]"""} 
])
      
}
