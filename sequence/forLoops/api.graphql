# A `@sequence` directive's behavior is not exactly linear.
# If at any stage, it produces N records, then the next stage is called once for every record in N.
# In the following, a Customer has a list of order ids in the field `orderList`.
# We will use `@materializer` to generate the order details for each of the ids in the list.
# We do that by using `@sequence`.
# The first query in the sequence echoes back the id list to help drive the next stage.
# The second query gets order details for each of these ids

type Customer {
  name: String
  city: String
  orderList: [ID]
}
type Order {
  id: ID
  product: ID
}
type Query {
  # Queries `customer`,`orderDetail`, and `echo` use an ecmascript return.
  # See https://stepzen.com/docs/custom-graphql-directives/directives#ecmascript for more information on `ecmascript`.
  # We are picturing a real-life scenario in which you call a customer datasource using the `endpoint` argument.
  # See https://stepzen.com/docs/connecting-backends/how-to-connect-a-rest-service for more information on `@rest`.

  customer(id: ID): Customer
    @rest(
      endpoint: "stepzen:empty"
      ecmascript: """
      function transformREST(s) {
          var id = get('id')
          if (id==1)
              return (JSON.stringify({"name":"John Doe","city":"Miami", "orderList":[1,3]}))
          else
              return (JSON.stringify({"name":"Jane Smith","city":"Santa Clara", "orderList":[2,4]}))
      }
      """
    )
  orderDetail(id: ID): Order
    @rest(
      endpoint: "stepzen:empty"
      ecmascript: """
      function transformREST(s) {
          var id = get('id')
          return (JSON.stringify({"id":id, "product":id+10}))
      }
      """
    )
  # This is a sequence. The first query in the sequence is an echo, generating a 'for loop'.
  # The second query gets called for each entry in the 'for loop'.

  allOrders(ids: [ID]): [Order]
    @sequence(steps: [{ query: "echo" }, { query: "orderDetail" }])

  echo(ids: [ID]): [ID]
    @rest(
      endpoint: "stepzen:empty"
      ecmascript: """
      function transformREST(s){
          var ids = get('ids')
          return ids
      }
      """
    )
}

# Now that we have a query that can generate order details for all order ids in the list,
# we can use an @materializer to connect Order to Customer
# We need to map the argument, as shown below.

extend type Customer {
  orderDetails: [Order]
    @materializer(
      query: "allOrders"
      arguments: [{ name: "ids", field: "orderList" }]
    )
}
